133. Clone Graph

class Solution {
    Node* dfs(Node* curr, unordered_map<Node*, Node*>& mp) {
        if (curr == nullptr) return nullptr;

        // if already cloned, return it
        if (mp.count(curr)) return mp[curr];

        // create clone and store it BEFORE visiting neighbors (handles cycles)
        Node* clone = new Node(curr->val);
        mp[curr] = clone;

        // clone neighbours (note: use the exact member name your Node class has;
        // LeetCode uses `neighbors` without underscore)
        for (auto it : curr->neighbors) {
            clone->neighbors.push_back(dfs(it, mp));
        }

        return clone;
    }

public:
    Node* cloneGraph(Node* node) {
        if (node == nullptr) return nullptr;

        unordered_map<Node*, Node*> mp;
        return dfs(node, mp);
    }
};
